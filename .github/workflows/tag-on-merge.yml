name: Tag on Release PR Merge

on:
  pull_request:
    types: [closed]
  push:
    branches: [main]

jobs:
  tag_from_pr:
    if: github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main' && startsWith(github.event.pull_request.head.ref, 'release/v')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Create tag at merge commit (PR close)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUM: ${{ github.event.pull_request.number }}
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
        run: |
          set -euo pipefail
          TAG="${HEAD_REF#release/}"
          echo "Preparing tag ${TAG} for PR #${PR_NUM}"
          git fetch origin main --force
          git fetch --tags --force
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "Tag ${TAG} already exists, skipping"
            exit 0
          fi
          # Try to get the exact merge commit associated with the PR
          SHA=$(gh pr view "$PR_NUM" --json mergeCommit -q .mergeCommit.oid || echo "")
          if [ -z "$SHA" ] || ! git cat-file -e "$SHA^{commit}" 2>/dev/null; then
            echo "mergeCommit not available; searching main for the release commit message"
            SHA=$(git rev-list -n 1 origin/main --grep "^chore(release): ${TAG#v}$") || true
          fi
          if [ -z "$SHA" ]; then
            echo "Falling back to current tip of origin/main"
            SHA=$(git rev-parse origin/main)
          fi
          echo "Tagging ${TAG} at ${SHA}"
          git tag -a "${TAG}" -m "release ${TAG}" "$SHA"
          git push origin "${TAG}"

  tag_from_push:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/heads/main')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Create tag on main push matching release commit message
        run: |
          set -euo pipefail
          MSG=$(git log -1 --pretty=%B)
          echo "Last commit message: $MSG"
          # Pattern A: direct release commit message
          TAG=$(echo "$MSG" | sed -nE 's/^chore\(release\): (v[0-9]+\.[0-9]+\.[0-9]+)$/\1/p')
          if [ -z "${TAG:-}" ]; then
            # Pattern B: merge commit message containing source branch like ... from <org>/release/vX.Y.Z
            BR=$(echo "$MSG" | sed -nE 's#^Merge pull request #[0-9]+ from [^/]*/(release/v[0-9]+\.[0-9]+\.[0-9]+).*#\1#p')
            if [ -n "${BR:-}" ]; then
              TAG="${BR#release/}"
            fi
          fi
          if [ -z "${TAG:-}" ]; then
            echo "No release tag found in commit message; querying recent merged PRs"
            if command -v gh >/dev/null 2>&1; then
              CAND=$(gh pr list --state merged --base main --json headRefName,mergeCommit -L 10 --jq '[.[] | select(.headRefName|startswith("release/v"))][0]')
              if [ -n "$CAND" ]; then
                TAG=$(echo "$CAND" | sed -nE 's#.*"headRefName":"release/(v[0-9]+\.[0-9]+\.[0-9]+)".*#\1#p')
                SHA=$(echo "$CAND" | sed -nE 's#.*"mergeCommit":"([a-f0-9]{40})".*#\1#p')
              fi
            fi
          fi
          if [ -z "${TAG:-}" ]; then
            echo "No release information found; skipping"
            exit 0
          fi
          git fetch --tags --force
          if git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            echo "Tag ${TAG} already exists; skipping"
            exit 0
          fi
          if [ -z "${SHA:-}" ]; then
            SHA=$(git rev-parse HEAD)
          fi
          echo "Tagging ${TAG} at ${SHA}"
          git tag -a "${TAG}" -m "release ${TAG}" "$SHA"
          git push origin "${TAG}"
